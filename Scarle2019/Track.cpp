#pragma once
#include "Track.h"
#include "pch.h"
#include <iostream>
#include <fstream>

Track::Track(RenderData* _RD, string _filename) : PhysModel(_RD, _filename)
{
	//Read in track config
	std::ifstream i(m_filepath.generateConfigFilepath(_filename, m_filepath.MODEL));
	json m_track_data_j;
	m_track_data_j << i;

	//Save config to our data struct
	m_track_data.scale = m_track_data_j["modelscale"];
	m_track_data.spawn_pos = Vector3(m_track_data_j["start_x"], m_track_data_j["start_z"], m_track_data_j["start_y"]);
	m_track_data.spawn_pos = m_track_data.spawn_pos * m_track_data.scale;
	m_track_data.start_rot = Vector3(m_track_data_j["rot_x"], m_track_data_j["rot_y"], m_track_data_j["rot_z"]); //Hmm, allow this? Will mess with collision.

	//Set our config in action
	SetScale(m_track_data.scale);
	SetRotationInDegrees(m_track_data.start_rot);

	//Debug output
	std::cout << "Loaded track data: " << m_track_data_j["asset_name"] << std::endl;
	std::cout << "Suitable spawn spot: " << m_track_data.spawn_pos.x << ", " << m_track_data.spawn_pos.y << ", " << m_track_data.spawn_pos.z << std::endl;

	//Load track vertex list for generating our collmap
	LoadVertexList(m_filepath.generateFilepath(_filename, m_filepath.MODEL_COLLMAP));
}

/* Returns a suitable spawn location for a player in this map */
Vector3 Track::getSuitableSpawnSpot() {
	return m_track_data.spawn_pos;
}

/* Takes the list of vertices generated by the model tool, and creates a vector of MeshTri's with it */
void Track::LoadVertexList(string _vertex_list)
{
	std::ifstream file(_vertex_list);
	string line;


	if (file.is_open())
	{
		while (std::getline(file, line))
		{
			CreateAndAddTriangle(line);
		}
	}
}

/* Takes a line from the file and extract a triangle out of it */
void Track::CreateAndAddTriangle(string _line)
{
	Vector vectors[3];
	string value = "";
	int vectorIndex = 0;

	for (char& c : _line)
	{
		if (c == '(' || c == ' ' || (value == "" && c == ','))
		{
			continue;
		}
		else if (c == ')')
		{
			vectors[vectorIndex] = CreateVector(value);
			vectorIndex++;
			value = "";
			// Once 3 vectors have been found, create a triangle
			if (vectorIndex == 3)
			{
				triangles.push_back(MeshTri(vectors[0] * m_track_data.scale, vectors[1] * m_track_data.scale, vectors[2] * m_track_data.scale));
				vectorIndex = 0;
			}
		}
		else
		{
			value += c;
		}
	}
}

/* Takes a part from the file and extracts the Vector it represents out */
Vector Track::CreateVector(string _vector)
{
	string value = "";
	float values[3];
	int pointIndex = 0;

	for (char& c : _vector)
	{
		// Once a comma is hit, thats the end of this value
		if (c == ',')
		{
			values[pointIndex] = std::stof(value);
			value = "";
			pointIndex++;
		}
		else
		{
			value += c;
		}
	}
	values[2] = std::stof(value);
	return Vector(values[0], values[1], values[2]);
}

/* Checks through all triangles to see if this line intersects any of them. 
   The point of intersecion is stored in _intersect */
bool Track::DoesLineIntersect(Vector _direction, Vector _startPos, Vector& _intersect, MeshTri*& _tri)
{
	int index = 0;
	for (MeshTri& tri : triangles)
	{
		if (tri.DoesLineIntersect(_direction, _startPos, _intersect, _tri))
		{
			return true;
		}
		index++;
	}
	index = index;
	return false;
}